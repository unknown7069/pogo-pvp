<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Battle Summary</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    .summary-page { display:flex; flex-direction:column; height:100%; }
    .summary-header { padding:16px; text-align:center; font-weight:800; border-bottom:1px solid #e5e5e5; background:#fff; }
    .summary-body { flex:1 1 auto; display:flex; align-items:center; justify-content:center; background:#fafafa; }
    .summary-card { width:min(92%, 420px); background:#fff; border:1px solid #e5e5e5; border-radius:12px; padding:20px; text-align:center; }
    .summary-title { font-size:20px; font-weight:900; margin-bottom:8px; }
    .summary-sub { color:#555; font-weight:600; margin-bottom:16px; }
    .summary-actions { padding:12px; border-top:1px solid #eee; background:#fff; }
    .hidden { display:none !important; }
    .reward-section { margin-top:20px; border-top:1px solid #eee; padding-top:16px; text-align:center; }
    .reward-title { font-size:16px; font-weight:800; margin-bottom:12px; color:#222; }
    .reward-grid { display:flex; flex-wrap:wrap; justify-content:center; gap:12px; }
    .reward-item { display:flex; flex-direction:column; align-items:center; gap:6px; padding:10px; width:92px; border:1px solid #e5e5e5; border-radius:12px; background:#fdfdfd; box-shadow:0 1px 2px rgba(15,23,42,0.04); }
    .reward-item img { width:64px; height:64px; object-fit:contain; image-rendering:pixelated; }
    .reward-name { font-size:12px; font-weight:700; color:#333; text-transform:capitalize; }
    .reward-note { margin-top:10px; font-size:12px; color:#666; }
  </style>
  <script src="pokemon-types.js"></script>
  <script src="pokemon-moves-fast.js"></script>
  <script src="pokemon-moves-charged.js"></script>
  <script src="pokemon-species.js"></script>
  <script src="pokemon-stats.js"></script>
  <script src="pokemon-data.js"></script>
  <script src="collection.js"></script>
  <script src="rocket-teams.js"></script>
  <script src="shared.js"></script>
  <script src="saving.js"></script>
</head>
<body>
  <div class="phone phone-column">
    <main class="summary-page" role="main">
      <div class="summary-header">Battle Summary</div>
      <div class="summary-body">
        <div class="summary-card" id="summaryCard">
          <div class="summary-title" id="summaryTitle">Battle Result</div>
          <div class="summary-sub" id="summaryDetail"></div>
          <div class="reward-section hidden" id="rewardSection">
            <div class="reward-title" id="rewardTitle">New Pokemon Unlocked!</div>
            <div class="reward-grid" id="rewardGrid"></div>
            <div class="reward-note" id="rewardNote">Added to your collection!</div>
          </div>
          <button class="btn btn-primary" id="backBtn" type="button">Return to Rocket Select</button>
        </div>
      </div>
    </main>
  </div>
  <script>
    (function(){
      function setText(el, text){ if (el) el.textContent = text; }
      const readState = (typeof window.readState === 'function')
        ? window.readState
        : function () {
            try {
              const raw = window.localStorage ? window.localStorage.getItem('pogo-pvp-state') : null;
              return raw ? JSON.parse(raw) : {};
            } catch (_) {
              return {};
            }
          };
      const writeState = (typeof window.writeState === 'function')
        ? window.writeState
        : function (patch) {
            if (!patch || Object(patch) !== patch) return;
            try {
              const current = readState();
              const next = Object.assign({}, current, patch);
              if (window.localStorage) {
                window.localStorage.setItem('pogo-pvp-state', JSON.stringify(next));
              }
            } catch (_) {}
          };
      let r = readState().lastBattleResult || null;
      const titleEl = document.getElementById('summaryTitle');
      const detailEl = document.getElementById('summaryDetail');
      const backBtn = document.getElementById('backBtn');
      const rewardSection = document.getElementById('rewardSection');
      const rewardGrid = document.getElementById('rewardGrid');
      const rewardTitle = document.getElementById('rewardTitle');
      const rewardNote = document.getElementById('rewardNote');
      const PD = window.PokemonData || {};
      const Collection = window.PlayerCollection || {};
      const MAX_REWARD_COUNT = 3;

      const DEFAULT_ROCKET_STAGES = [
        { id: 'grunt-male', team: [ { level: 5 }, { level: 5 }, { level: 7 } ] },
        { id: 'grunt-female', team: [ { level: 7 }, { level: 7 }, { level: 9 } ] },
        { id: 'cliff', team: [ { level: 40 }, { level: 42 }, { level: 43 } ] },
        { id: 'arlo', team: [ { level: 39 }, { level: 41 }, { level: 43 } ] },
        { id: 'sierra', team: [ { level: 38 }, { level: 40 }, { level: 42 } ] },
        { id: 'giovanni', team: [ { level: 45 }, { level: 47 }, { level: 50 } ] },
      ];

      function clampRewardLevel(value) {
        let n = Number(value);
        if (!Number.isFinite(n)) return 20;
        if (n < 1) n = 1;
        if (n > 50) n = 50;
        return Math.round(n * 2) / 2;
      }

      function findRocketStage() {
        if (!r) return null;
        const stages = Array.isArray(window.RocketTeams) ? window.RocketTeams : [];
        const fallbackStages = DEFAULT_ROCKET_STAGES;
        const numericIndex = Number(r && r.stageIndex);
        const stageId = r && r.stageId;

        function hasTeam(candidate) {
          return candidate && Array.isArray(candidate.team) && candidate.team.length;
        }

        let stage = Number.isFinite(numericIndex) && numericIndex >= 0 && numericIndex < stages.length
          ? stages[numericIndex]
          : null;

        if (!hasTeam(stage) && typeof window.getRocketStageByIndex === 'function' && Number.isFinite(numericIndex)) {
          try {
            const candidate = window.getRocketStageByIndex(numericIndex);
            if (hasTeam(candidate)) stage = candidate;
          } catch (_) {}
        }

        if (!hasTeam(stage) && stageId && typeof window.getRocketStageById === 'function') {
          try {
            const candidate = window.getRocketStageById(stageId);
            if (hasTeam(candidate)) stage = candidate;
          } catch (_) {}
        }

        if (!hasTeam(stage) && stageId && stages.length) {
          stage = stages.find(function (entry) { return entry && entry.id === stageId; }) || stage;
        }

        if (!hasTeam(stage) && stageId) {
          stage = fallbackStages.find(function (entry) { return entry && entry.id === stageId; }) || stage;
        }

        if (!hasTeam(stage) && Number.isFinite(numericIndex) && numericIndex >= 0) {
          stage = fallbackStages[numericIndex] || stage;
        }

        return hasTeam(stage) ? stage : null;
      }

      function resolveRewardLevel() {
        const stage = findRocketStage();
        if (stage && Array.isArray(stage.team) && stage.team.length) {
          const member = stage.team[0];
          if (member && member.level != null) {
            return clampRewardLevel(member.level);
          }
        }
        if (r && r.firstOpponentLevel != null) {
          return clampRewardLevel(r.firstOpponentLevel);
        }
        return 20;
      }
      const rewardLevel = resolveRewardLevel();
      function getEligibleSpeciesPool() {
        const list = PD && Array.isArray(PD.all) ? PD.all : [];
        if (!list.length) return [];
        function computeMaxCp(species) {
          if (!species) return null;
          if (Number.isFinite(species.maxCp)) return Number(species.maxCp);
          if (species.baseStats && typeof PD.calcGoCp === 'function') {
            try { return Number(PD.calcGoCp(species.baseStats)); } catch (_) { return null; }
          }
          return null;
        }
        const mapped = list.map(function (species, index) {
          return { species: species, cp: computeMaxCp(species), index: index };
        }).filter(function (entry) {
          return entry.species && Number.isFinite(entry.species.id);
        });
        mapped.sort(function (a, b) {
          const cpA = Number.isFinite(a.cp) ? a.cp : Infinity;
          const cpB = Number.isFinite(b.cp) ? b.cp : Infinity;
          if (cpA !== cpB) return cpA - cpB;
          return a.index - b.index;
        });
        if (typeof console !== 'undefined') {
          const debugRows = mapped.map(function (entry) {
            return { name: entry.species.name || entry.species.speciesName || ('#' + entry.species.id), maxCp: entry.cp };
          });
          if (console.table) console.table(debugRows, ['name', 'maxCp']); else console.log('[Battle Summary] Eligible species pool', debugRows);
        }
        return mapped.map(function (entry) { return entry.species; });
      }
      function pickRandomSpecies(count) {
        if (!Number.isFinite(count) || count <= 0) return [];
        const pool = getEligibleSpeciesPool();
        if (!pool.length) return [];
        const stage = findRocketStage();
        const stages = Array.isArray(window.RocketTeams) && window.RocketTeams.length
          ? window.RocketTeams
          : DEFAULT_ROCKET_STAGES;
        const stageCount = stages.length || 1;
        const numericIndex = Number(r && r.stageIndex);
        function computeDifficulty(entry) {
          if (!entry || !Array.isArray(entry.team) || !entry.team.length) return 0;
          let maxLevel = 0;
          for (let i = 0; i < entry.team.length; i++) {
            const member = entry.team[i];
            const lvl = Number(member && member.level);
            if (Number.isFinite(lvl) && lvl > maxLevel) maxLevel = lvl;
          }
          return maxLevel;
        }
        const rankedStages = stages.map(function (entry, idx) {
          return { entry: entry, idx: idx, score: computeDifficulty(entry) };
        }).sort(function (a, b) {
          if (a.score === b.score) return a.idx - b.idx;
          return a.score - b.score;
        });
        let targetEntry = stage || (Number.isFinite(numericIndex) && numericIndex >= 0 && numericIndex < stages.length ? stages[numericIndex] : null);
        let normalizedIndex = -1;
        if (targetEntry) {
          const targetId = targetEntry.id;
          normalizedIndex = rankedStages.findIndex(function (item) {
            return item.entry && item.entry.id === targetId;
          });
        }
        if (normalizedIndex < 0) {
          normalizedIndex = Number.isFinite(numericIndex) && numericIndex >= 0 ? Math.min(numericIndex, rankedStages.length - 1) : 0;
        }
        if (normalizedIndex < 0) normalizedIndex = 0;
        if (normalizedIndex >= rankedStages.length) normalizedIndex = rankedStages.length - 1;
        const segmentSize = Math.max(1, Math.ceil(pool.length / rankedStages.length));
        let start = normalizedIndex * segmentSize;
        if (start >= pool.length) start = pool.length - segmentSize;
        if (start < 0) start = 0;
        let end = start + segmentSize;
        if (end > pool.length) end = pool.length;
        const segment = pool.slice(start, end);
        if (!segment.length) return [];
        const max = Math.min(segment.length, Math.floor(count));
        const used = new Set();
        const picks = [];
        while (picks.length < max && used.size < segment.length) {
          const idx = Math.floor(Math.random() * segment.length);
          const candidate = segment[idx];
          if (!candidate || used.has(candidate.id)) continue;
          used.add(candidate.id);
          picks.push(candidate);
        }
        return picks;
      }
      function awardPokemon(speciesList) {
        const createPokemon = Collection && typeof Collection.createPokemon === 'function'
          ? Collection.createPokemon
          : null;
        if (!Array.isArray(speciesList) || !speciesList.length) return [];
        const results = [];
        function appendToCollection(entry) {
          if (!entry || !Number.isFinite(entry.id)) return null;
          const state = readState();
          const list = Array.isArray(state.playerPokemon) ? state.playerPokemon.slice() : [];
          if (entry.uid && list.some(function (item) { return item && item.uid === entry.uid; })) {
            return entry;
          }
          list.push(entry);
          try {
            writeState({ playerPokemon: list });
          } catch (_) {}
          return entry;
        }
        for (let i = 0; i < speciesList.length; i++) {
          const species = speciesList[i];
          if (!species || !Number.isFinite(species.id)) continue;
          let created = null;
          if (createPokemon) {
            try {
              created = createPokemon({
                id: Number(species.id),
                name: species.name,
                level: rewardLevel
              });
            } catch (_) {}
          }
          if (created && created.uid) {
            appendToCollection(created);
            results.push({
              id: Number(species.id),
              name: species.name || null,
              uid: created.uid,
              level: rewardLevel
            });
            continue;
          }
          const fallbackUid = 'pk_reward_' + Date.now().toString(36) + '_' + i + '_' + Math.random().toString(36).slice(2, 6);
          const fallbackEntry = appendToCollection({
            uid: fallbackUid,
            id: Number(species.id),
            level: rewardLevel,
            name: species.name || null,
            createdAt: Date.now()
          });
          results.push({
            id: Number(species.id),
            name: species.name || null,
            uid: fallbackEntry && fallbackEntry.uid ? fallbackEntry.uid : fallbackUid,
            level: rewardLevel
          });
        }
        return results;
      }
      function renderRewards(list, options) {
        if (!Array.isArray(list) || !list.length || !rewardGrid) return;
        if (rewardSection && rewardSection.classList) {
          rewardSection.classList.remove('hidden');
        } else if (rewardSection) {
          rewardSection.style.display = 'block';
        }
        rewardGrid.textContent = '';
        const alreadyClaimed = options && options.alreadyClaimed;
        if (rewardTitle) {
          setText(rewardTitle, alreadyClaimed ? 'Unlocked Pokemon' : 'New Pokemon Unlocked!');
        }
        if (rewardNote) {
          setText(rewardNote, alreadyClaimed ? 'Already added to your collection.' : 'Added to your collection!');
        }
        for (let i = 0; i < list.length; i++) {
          const info = list[i];
          if (!info || !Number.isFinite(info.id)) continue;
          const wrapper = document.createElement('div');
          wrapper.className = 'reward-item';
          const mon = PD && typeof PD.getPokemonById === 'function' ? PD.getPokemonById(info.id) : null;
          const displayName = info.name || (mon && mon.name) || ('#' + info.id);
          let spriteUrl = '';
          if (PD && typeof PD.getForwardSpriteUrl === 'function') {
            try {
              spriteUrl = PD.getForwardSpriteUrl(mon || displayName);
            } catch (_) {}
          }
          if (!spriteUrl && mon && mon.sprite) {
            spriteUrl = mon.sprite;
          }
          if (spriteUrl) {
            const img = document.createElement('img');
            img.alt = displayName;
            img.src = spriteUrl;
            wrapper.appendChild(img);
          }
          const label = document.createElement('div');
          label.className = 'reward-name';
          label.textContent = displayName;
          wrapper.appendChild(label);
          rewardGrid.appendChild(wrapper);
        }
      }
      let title = 'Battle Result';
      let detail = '';
      if (r && r.outcome) {
        if (r.outcome === 'win') title = 'You Won!';
        else if (r.outcome === 'lose') title = 'You Lost';
        else if (r.outcome === 'forfeit') title = 'You Forfeited';
        else if (r.outcome === 'tie') title = 'It\'s a Tie!';
        const vs = r.opponent ? `Opponent: ${r.opponent}` : '';
        detail = vs;
      } else {
        detail = 'No recent battle information.';
      }
      setText(titleEl, title);
      setText(detailEl, detail);
      if (r && r.outcome === 'win') {
        const existing = Array.isArray(r.rewardPokemon)
          ? r.rewardPokemon.filter(function (item) { return item && Number.isFinite(item.id); })
          : [];
        if (r.rewardClaimed && existing.length) {
          renderRewards(existing, { alreadyClaimed: true });
        } else {
          const picks = pickRandomSpecies(MAX_REWARD_COUNT);
          const awarded = awardPokemon(picks);
          if (awarded.length) {
            renderRewards(awarded, { alreadyClaimed: false });
            const nextResult = Object.assign({}, r || {}, {
              rewardClaimed: true,
              rewardPokemon: awarded
            });
            writeState({ lastBattleResult: nextResult });
            r = nextResult;
          }
        }
      }
      function goBack(){ window.location.href = 'rocket-select.html'; }
      if (backBtn) backBtn.addEventListener('click', goBack);
    })();
  </script>
</body>
</html>
