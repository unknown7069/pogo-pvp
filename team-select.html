<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Team Select</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="phone phone-column team-select-page">
    <div class="team-header">team select</div>
    <div class="top-select">
      <div class="slot" data-slot="0">Empty</div>
      <div class="slot" data-slot="1">Empty</div>
      <div class="slot" data-slot="2">Empty</div>
    </div>
    <div class="pokemon-grid" id="pokemonGrid"></div>
    <div class="actions action-bar two">
      <button class="btn btn-secondary" id="cancelBtn">Cancel</button>
      <button class="btn btn-primary" id="doneBtn">Done</button>
    </div>
  </div>
  <script src="pokemon-types.js"></script>
  <script src="pokemon-moves-fast.js"></script>
  <script src="pokemon-moves-charged.js"></script>
  <script src="pokemon-species.js"></script>
  <script src="pokemon-stats.js"></script>
  <script src="pokemon-data.js"></script>
  <script src="shared.js"></script>
  <script>
    (function(){
      const MAX_TEAM = 3;

      const PD = window.PokemonData || {};
      const grid = document.getElementById('pokemonGrid');
      const slots = Array.from(document.querySelectorAll('.slot'));
      const cancelBtn = document.getElementById('cancelBtn');
      const doneBtn = document.getElementById('doneBtn');

      const list = Array.isArray(PD.all) && PD.all.length ? PD.all : [];
      // Toggle sprite rendering in the grid
      const SHOW_SPRITES = true;

      // Map for fast button lookups by id
      const buttonsById = new Map();
      // Track previous selected set to diff UI updates
      let prevSelected = new Set();

      function renderGrid() {
        // Clear and batch-insert for minimal reflow
        grid.textContent = '';
        const frag = document.createDocumentFragment();
        list.forEach((mon) => {
          const card = document.createElement('div');
          card.className = 'pokemon-card';

          const btn = document.createElement('button');
          btn.className = 'pokemon-btn';
          btn.type = 'button';
          btn.dataset.id = String(mon.id);
          btn.dataset.name = mon.name;
          btn.setAttribute('aria-pressed', 'false');

          // Compute CP from GO stats
          let cp = 10;
          try {
            const stats = PD.getGoStatsById ? PD.getGoStatsById(mon.id) : null;
            cp = PD.calcGoCp && stats ? PD.calcGoCp(stats) : 10;
          } catch (_) { /* ignore */ }

          // Get sprite URL from central helper
          const imgUrl = PD.getForwardSpriteUrl ? PD.getForwardSpriteUrl(mon) : '';

          // Top: CP (overlay inside container)
          const cpEl = document.createElement('div');
          cpEl.className = 'cp';
          cpEl.textContent = `CP ${cp}`;

          // Bottom: name (overlay inside container)
          const nameEl = document.createElement('div');
          nameEl.className = 'name';
          nameEl.textContent = mon.name;

          if (SHOW_SPRITES && imgUrl) {
            const spriteWrap = document.createElement('div');
            spriteWrap.className = 'sprite-wrap';
            spriteWrap.style.backgroundImage = `url('${imgUrl}')`;
            btn.appendChild(spriteWrap);
          }

          // Compose container: button + overlays
          card.appendChild(btn);
          card.appendChild(cpEl);
          card.appendChild(nameEl);

          // Track button for selection highlighting
          buttonsById.set(Number(mon.id), btn);
          frag.appendChild(card);
        });
        grid.appendChild(frag);
      }

      let workingTeam = [];

      function readState() {
        try {
          const raw = localStorage.getItem('pogo-pvp-state');
          return raw ? JSON.parse(raw) : {};
        } catch (_) { return {}; }
      }

      function writeState(patch) {
        try {
          const state = readState();
          const next = Object.assign({}, state, patch);
          localStorage.setItem('pogo-pvp-state', JSON.stringify(next));
        } catch (_) { /* ignore */ }
      }

      function getNameById(id){
        const mon = (PD.byId && PD.byId.get) ? PD.byId.get(Number(id)) : null;
        return (mon && mon.name) || 'Unknown';
      }

      function loadExisting() {
        const state = readState();
        const savedIds = Array.isArray(state.selectedTeamIds) ? state.selectedTeamIds : [];
        workingTeam = savedIds.slice(0, MAX_TEAM).map(Number).filter(n => !Number.isNaN(n));
        updateSlots();
        updateGridSelection();
      }

      function updateSlots() {
        for (let i = 0; i < MAX_TEAM; i++) {
          const slot = slots[i];
          const id = workingTeam[i];
          // Reset slot contents each update
          slot.textContent = '';

          if (typeof id === 'number') {
            // Try to show a forward-facing sprite, fallback to name
            const mon = (PD.getPokemonById ? PD.getPokemonById(id) : (PD.byId && PD.byId.get ? PD.byId.get(Number(id)) : null));
            const name = (mon && mon.name) || getNameById(id);

            let showedImage = false;
            if (mon && typeof PD.getForwardSpriteUrl === 'function') {
              try {
                const url = PD.getForwardSpriteUrl(mon);
                if (url) {
                  const img = document.createElement('img');
                  img.className = 'slot-img';
                  img.alt = name;
                  img.decoding = 'async';
                  img.loading = 'lazy';
                  img.draggable = false;
                  img.src = url;
                  img.addEventListener('error', () => {
                    // Fallback to text name if image fails to load
                    if (slot.contains(img)) slot.removeChild(img);
                    slot.textContent = name;
                  });
                  slot.appendChild(img);
                  showedImage = true;
                }
              } catch (_) { /* ignore */ }
            }

            if (!showedImage) {
              slot.textContent = name;
            }
            slot.title = name;
            slot.classList.add('filled');
          } else {
            slot.textContent = '';
            slot.removeAttribute('title');
            slot.classList.remove('filled');
          }
        }
      }

      function updateGridSelection() {
        const selected = new Set(workingTeam);
        // Remove selection for items no longer selected
        prevSelected.forEach((id) => {
          if (!selected.has(id)) {
            const btn = buttonsById.get(Number(id));
            if (btn) {
              btn.classList.remove('selected');
              btn.setAttribute('aria-pressed', 'false');
            }
          }
        });
        // Add selection for new items
        selected.forEach((id) => {
          if (!prevSelected.has(id)) {
            const btn = buttonsById.get(Number(id));
            if (btn) {
              btn.classList.add('selected');
              btn.setAttribute('aria-pressed', 'true');
            }
          }
        });
        prevSelected = selected;
      }

      // Clicking a pokemon adds/removes from working team (max MAX_TEAM)
      grid.addEventListener('click', (e) => {
        const btn = e.target.closest('.pokemon-btn');
        if (!btn) return;
        const id = Number(btn.dataset.id || 0);
        const i = workingTeam.indexOf(id);
        if (i !== -1) {
          workingTeam.splice(i, 1);
        } else if (workingTeam.length < MAX_TEAM) {
          workingTeam.push(id);
        } else {
          // Team is full; ignore extra selections
          return;
        }
        updateSlots();
        updateGridSelection();
      });

      // Bottom actions
      cancelBtn.addEventListener('click', () => {
        // Do not persist working changes; just return
        window.location.href = 'rocket-select.html';
      });
      doneBtn.addEventListener('click', () => {
        const finalTeamIds = workingTeam.slice(0, MAX_TEAM).map(Number);
        const finalTeamNames = finalTeamIds.map(getNameById);
        writeState({ selectedTeamIds: finalTeamIds, selectedTeam: finalTeamNames });
        // Navigate directly; team is in localStorage now
        window.location.href = 'battle.html';
      });

      // Enable click-and-drag scrolling using shared helper
      if (window.UI && typeof window.UI.attachDragScroll === 'function') {
        window.UI.attachDragScroll(grid);
      }

      // Initial render + hydrate from saved state
      renderGrid();
      loadExisting();
    })();
  </script>
</body>
</html>
