<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Team Select</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="phone phone-column team-select-page">
    <div class="team-header">team select</div>
    <div class="top-select">
      <div class="slot" data-slot="0">Empty</div>
      <div class="slot" data-slot="1">Empty</div>
      <div class="slot" data-slot="2">Empty</div>
    </div>
    <div class="pokemon-grid" id="pokemonGrid"></div>
    <div class="actions action-bar two">
      <button class="btn btn-secondary" id="cancelBtn">Cancel</button>
      <button class="btn btn-primary" id="doneBtn">Done</button>
    </div>
  </div>
  <script src="pokemon-types.js"></script>
  <script src="pokemon-moves-fast.js"></script>
  <script src="pokemon-moves-charged.js"></script>
  <script src="pokemon-species.js"></script>
  <script src="pokemon-stats.js"></script>
  <script src="pokemon-data.js"></script>
  <script src="shared.js"></script>
  <script>
    (function(){
      const MAX_TEAM = 3;

      const PD = window.PokemonData || {};
      const grid = document.getElementById('pokemonGrid');
      const slots = Array.from(document.querySelectorAll('.slot'));
      const cancelBtn = document.getElementById('cancelBtn');
      const doneBtn = document.getElementById('doneBtn');

      const list = Array.isArray(PD.all) && PD.all.length ? PD.all : [];

      // Map for fast button lookups by id
      const buttonsById = new Map();
      // Track previous selected set to diff UI updates
      let prevSelected = new Set();

      function renderGrid() {
        // Clear and batch-insert for minimal reflow
        grid.textContent = '';
        const frag = document.createDocumentFragment();
        list.forEach((mon) => {
          const btn = document.createElement('button');
          btn.className = 'pokemon-btn';
          btn.type = 'button';
          btn.textContent = mon.name;
          btn.dataset.id = String(mon.id);
          btn.dataset.name = mon.name;
          btn.setAttribute('aria-pressed', 'false');
          buttonsById.set(Number(mon.id), btn);
          frag.appendChild(btn);
        });
        grid.appendChild(frag);
      }

      let workingTeam = [];

      function readState() {
        try {
          const raw = localStorage.getItem('pogo-pvp-state');
          return raw ? JSON.parse(raw) : {};
        } catch (_) { return {}; }
      }

      function writeState(patch) {
        try {
          const state = readState();
          const next = Object.assign({}, state, patch);
          localStorage.setItem('pogo-pvp-state', JSON.stringify(next));
        } catch (_) { /* ignore */ }
      }

      function getNameById(id){
        const mon = (PD.byId && PD.byId.get) ? PD.byId.get(Number(id)) : null;
        return (mon && mon.name) || 'Unknown';
      }

      function loadExisting() {
        const state = readState();
        const savedIds = Array.isArray(state.selectedTeamIds) ? state.selectedTeamIds : [];
        workingTeam = savedIds.slice(0, MAX_TEAM).map(Number).filter(n => !Number.isNaN(n));
        updateSlots();
        updateGridSelection();
      }

      function updateSlots() {
        for (let i = 0; i < MAX_TEAM; i++) {
          const slot = slots[i];
          const id = workingTeam[i];
          if (typeof id === 'number') {
            slot.textContent = getNameById(id);
            slot.classList.add('filled');
          } else {
            slot.textContent = 'Empty';
            slot.classList.remove('filled');
          }
        }
      }

      function updateGridSelection() {
        const selected = new Set(workingTeam);
        // Remove selection for items no longer selected
        prevSelected.forEach((id) => {
          if (!selected.has(id)) {
            const btn = buttonsById.get(Number(id));
            if (btn) {
              btn.classList.remove('selected');
              btn.setAttribute('aria-pressed', 'false');
            }
          }
        });
        // Add selection for new items
        selected.forEach((id) => {
          if (!prevSelected.has(id)) {
            const btn = buttonsById.get(Number(id));
            if (btn) {
              btn.classList.add('selected');
              btn.setAttribute('aria-pressed', 'true');
            }
          }
        });
        prevSelected = selected;
      }

      // Clicking a pokemon adds/removes from working team (max MAX_TEAM)
      grid.addEventListener('click', (e) => {
        const btn = e.target.closest('.pokemon-btn');
        if (!btn) return;
        const id = Number(btn.dataset.id || 0);
        const i = workingTeam.indexOf(id);
        if (i !== -1) {
          workingTeam.splice(i, 1);
        } else if (workingTeam.length < MAX_TEAM) {
          workingTeam.push(id);
        } else {
          // Team is full; ignore extra selections
          return;
        }
        updateSlots();
        updateGridSelection();
      });

      // Bottom actions
      cancelBtn.addEventListener('click', () => {
        // Do not persist working changes; just return
        window.location.href = 'rocket-select.html';
      });
      doneBtn.addEventListener('click', () => {
        const finalTeamIds = workingTeam.slice(0, MAX_TEAM).map(Number);
        const finalTeamNames = finalTeamIds.map(getNameById);
        writeState({ selectedTeamIds: finalTeamIds, selectedTeam: finalTeamNames });
        // Navigate directly; team is in localStorage now
        window.location.href = 'battle.html';
      });

      // Enable click-and-drag scrolling using shared helper
      if (window.UI && typeof window.UI.attachDragScroll === 'function') {
        window.UI.attachDragScroll(grid);
      }

      // Initial render + hydrate from saved state
      renderGrid();
      loadExisting();
    })();
  </script>
</body>
</html>
