<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Team Select</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="phone phone-column team-select-page">
    <div class="team-header">team select</div>
    <div class="top-select">
      <div class="slot" data-slot="0">Empty</div>
      <div class="slot" data-slot="1">Empty</div>
      <div class="slot" data-slot="2">Empty</div>
    </div>
    <div class="pokemon-grid" id="pokemonGrid"></div>
    <div class="actions action-bar two">
      <button class="btn btn-secondary" id="cancelBtn">Cancel</button>
      <button class="btn btn-primary" id="doneBtn">Done</button>
    </div>
  </div>
  <script src="../dist/data/pokemon-types.js"></script>
  <script src="../dist/data/pokemon-moves-fast.js"></script>
  <script src="../dist/data/pokemon-moves-charged.js"></script>
  <script src="../dist/data/pokemon-species.js"></script>
  <script src="../dist/data/pokemon-stats.js"></script>
  <script src="../dist/data/pokemon-data.js"></script>
  <script src="../dist/system/shared.js"></script>
  <script src="../dist/system/saving.js"></script>
  <script>
    (function(){
      const MAX_TEAM = 3;

      const store = window.AppState || null;
      const PD = window.PokemonData || {};
      const grid = document.getElementById('pokemonGrid');
      const slots = Array.from(document.querySelectorAll('.slot'));
      const cancelBtn = document.getElementById('cancelBtn');
      const doneBtn = document.getElementById('doneBtn');
      if (!grid) return;

      const SHOW_SPRITES = true;

      const readState = (typeof window.readState === 'function')
        ? window.readState
        : function () {
          if (store && typeof store.read === 'function') return store.read();
          if (store && typeof store.all === 'function') return store.all();
          try {
            const raw = window.localStorage ? window.localStorage.getItem('pogo-pvp-state') : null;
            return raw ? JSON.parse(raw) : {};
          } catch (_) {
            return {};
          }
        };

      const writeState = (typeof window.writeState === 'function')
        ? window.writeState
        : function (patch) {
          if (!patch || Object(patch) !== patch) return;
          if (store && typeof store.write === 'function') { store.write(patch); return; }
          if (store && typeof store.merge === 'function') { store.merge(patch); return; }
          if (store && typeof store.set === 'function') {
            Object.keys(patch).forEach((key) => store.set(key, patch[key]));
            return;
          }
          try {
            const next = Object.assign({}, readState(), patch);
            if (window.localStorage) {
              window.localStorage.setItem('pogo-pvp-state', JSON.stringify(next));
            }
          } catch (_) {}
        };

      const subscribeState = (typeof window.subscribeState === 'function')
        ? window.subscribeState
        : (store && typeof store.subscribe === 'function' ? store.subscribe.bind(store) : null);

      function sanitizeLevelValue(value) {
        let n = Number(value);
        if (Number.isNaN(n)) return null;
        n = Math.max(1, Math.min(n, 50));
        n = Math.round(n * 2) / 2;
        return n;
      }

      function sanitizeEntry(entry) {
        if (!entry || typeof entry !== 'object') return null;
        const uid = typeof entry.uid === 'string' && entry.uid ? entry.uid : null;
        const id = Number(entry.id);
        const level = sanitizeLevelValue(entry.level);
        if (!uid || Number.isNaN(id) || level == null) return null;
        const normalized = {
          uid,
          id,
          level,
          name: typeof entry.name === 'string' ? entry.name : null,
          createdAt: Number.isFinite(entry.createdAt) ? Number(entry.createdAt) : null,
        };
        if (entry.shiny != null) normalized.shiny = entry.shiny;
        if (entry.ivHp != null) normalized.ivHp = entry.ivHp;
        if (entry.ivAttack != null) normalized.ivAttack = entry.ivAttack;
        if (entry.ivDefense != null) normalized.ivDefense = entry.ivDefense;
        if (entry.ivs && typeof entry.ivs === 'object') {
          normalized.ivs = {
            hp: entry.ivs.hp,
            attack: entry.ivs.attack,
            defense: entry.ivs.defense,
          };
        }
        return normalized;
      }

      function getCollection(state) {
        const src = state && Array.isArray(state.playerPokemon) ? state.playerPokemon : [];
        const clean = [];
        for (let i = 0; i < src.length; i++) {
          const entry = sanitizeEntry(src[i]);
          if (entry) clean.push(entry);
        }
        return clean;
      }

      function collectionEquals(a, b) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) {
          const x = a[i];
          const y = b[i];
          if (!x || !y) return false;
          if (x.uid !== y.uid || x.id !== y.id || x.level !== y.level) return false;
        }
        return true;
      }

      function arrayEquals(a, b) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) return false;
        }
        return true;
      }

      function formatLevel(level) {
        const rounded = Math.round(level);
        if (Math.abs(level - rounded) < 0.01) return String(rounded);
        return level.toFixed(1).replace(/0+$/, '').replace(/\.$/, '');
      }

      function getMonById(source) {
        const entry = source && typeof source === 'object' ? source : null;
        const key = entry ? Number(entry.id) : Number(source);
        if (!Number.isFinite(key)) return { id: key, name: 'Pokemon', types: ['normal'], fastMoves: [], chargedMoves: [] };
        if (PD.getPokemonById) {
          const found = PD.getPokemonById(key, entry || undefined);
          if (found) return found;
        }
        if (PD.byId && typeof PD.byId.get === 'function') {
          const viaMap = PD.byId.get(key);
          if (viaMap) return viaMap;
        }
        return { id: key, name: 'Pokemon', types: ['normal'], fastMoves: [], chargedMoves: [] };
      }

      function computeCp(id, level) {
        try {
          if (PD.getGoStatsById) {
            const stats = PD.getGoStatsById(id, level);
            if (stats && PD.calcGoCp) {
              return Math.max(10, Math.round(PD.calcGoCp(stats)));
            }
          }
        } catch (_) {}
        return 10;
      }

      function getSpriteUrl(mon) {
        const name = (mon && mon.name) || 'Pokemon';
        const shiny = !!(mon && mon.shiny);
        if (PD.getBattleSpriteUrl) {
          try {
            const url = PD.getBattleSpriteUrl(name, 'opponent', shiny);
            if (url) return url;
          } catch (_) {}
        }
        if (PD.getForwardSpriteUrl) {
          try {
            const url = PD.getForwardSpriteUrl(name);
            if (url) return url;
          } catch (_) {}
        }
        return '';
      }

      function buildEntriesMap(list) {
        const map = new Map();
        for (let i = 0; i < list.length; i++) {
          map.set(list[i].uid, list[i]);
        }
        return map;
      }

      const stateSnapshot = readState();
      let collection = getCollection(stateSnapshot);
      let entriesByUid = buildEntriesMap(collection);
      const buttonsByUid = new Map();
      let workingTeam = [];
      let prevSelected = new Set();

      function updateGridSelection() {
        const selected = new Set(workingTeam);
        buttonsByUid.forEach((btn, uid) => {
          if (selected.has(uid)) {
            btn.classList.add('selected');
            btn.setAttribute('aria-pressed', 'true');
          } else {
            btn.classList.remove('selected');
            btn.setAttribute('aria-pressed', 'false');
          }
        });
        prevSelected = selected;
      }

      function renderGrid() {
        grid.textContent = '';
        buttonsByUid.clear();
        if (!collection.length) {
          const empty = document.createElement('div');
          empty.textContent = 'No Pokemon saved yet.';
          empty.className = 'empty-state';
          empty.style.padding = '32px 16px';
          empty.style.textAlign = 'center';
          empty.style.color = '#555';
          empty.style.fontWeight = '600';
          grid.appendChild(empty);
          return;
        }
        const frag = document.createDocumentFragment();
        collection.forEach((entry) => {
          const mon = getMonById(entry);
          const card = document.createElement('div');
          card.className = 'pokemon-card';

          const btn = document.createElement('button');
          btn.className = 'pokemon-btn';
          btn.type = 'button';
          btn.dataset.uid = entry.uid;
          btn.dataset.id = String(entry.id);
          btn.dataset.level = String(entry.level);
          btn.dataset.name = mon.name || 'Pokemon';
          btn.setAttribute('aria-pressed', 'false');
          btn.setAttribute('aria-label', `${mon.name || 'Pokemon'} level ${formatLevel(entry.level)}`);

          const cp = computeCp(entry.id, entry.level);
          const cpEl = document.createElement('div');
          cpEl.className = 'cp';
          cpEl.textContent = `Lvl ${formatLevel(entry.level)} | CP ${cp}`;

          const nameEl = document.createElement('div');
          nameEl.className = 'name';
          nameEl.textContent = mon.name || 'Pokemon';

          if (SHOW_SPRITES) {
            const spriteUrl = getSpriteUrl(mon);
            if (spriteUrl) {
              const spriteWrap = document.createElement('div');
              spriteWrap.className = 'sprite-wrap';
              spriteWrap.style.backgroundImage = `url('${spriteUrl}')`;
              btn.appendChild(spriteWrap);
            }
          }

          card.appendChild(btn);
          card.appendChild(cpEl);
          card.appendChild(nameEl);
          card.title = `${mon.name || 'Pokemon'} (Lvl ${formatLevel(entry.level)})`;

          buttonsByUid.set(entry.uid, btn);
          frag.appendChild(card);
        });
        grid.appendChild(frag);
        updateGridSelection();
      }

      function arrayFromStateTeam(state) {
        const next = [];
        const members = Array.isArray(state.selectedTeamMembers) ? state.selectedTeamMembers : null;
        if (members) {
          for (let i = 0; i < members.length && next.length < MAX_TEAM; i++) {
            const uid = members[i] && typeof members[i].uid === 'string' ? members[i].uid : null;
            if (uid && entriesByUid.has(uid) && !next.includes(uid)) next.push(uid);
          }
        }
        if (!next.length) {
          const savedUids = Array.isArray(state.selectedTeamUids) ? state.selectedTeamUids : [];
          for (let i = 0; i < savedUids.length && next.length < MAX_TEAM; i++) {
            const uid = typeof savedUids[i] === 'string' ? savedUids[i] : null;
            if (uid && entriesByUid.has(uid) && !next.includes(uid)) next.push(uid);
          }
        }
        if (!next.length) {
          const legacyIds = Array.isArray(state.selectedTeamIds) ? state.selectedTeamIds.map(Number).filter((n) => !Number.isNaN(n)) : [];
          const used = new Set();
          legacyIds.forEach((id) => {
            if (next.length >= MAX_TEAM) return;
            for (let i = 0; i < collection.length; i++) {
              const entry = collection[i];
              if (entry.id === id && !used.has(entry.uid)) {
                next.push(entry.uid);
                used.add(entry.uid);
                break;
              }
            }
          });
        }
        return next.slice(0, MAX_TEAM);
      }

      function updateSlots() {
        for (let i = 0; i < MAX_TEAM; i++) {
          const slot = slots[i];
          if (!slot) continue;
          const uid = workingTeam[i];
          slot.textContent = '';
          slot.removeAttribute('title');
          slot.removeAttribute('data-uid');
          slot.classList.remove('filled');
          while (slot.firstChild) slot.removeChild(slot.firstChild);

          if (!uid) continue;
          const entry = entriesByUid.get(uid);
          if (!entry) continue;
          const mon = getMonById(entry);
          const name = entry.name || (mon && mon.name) || 'Pokemon';
          const label = `${name} (Lvl ${formatLevel(entry.level)})`;
          slot.classList.add('filled');
          slot.setAttribute('data-uid', uid);
          slot.title = label;

          const spriteUrl = getSpriteUrl(mon);
          if (spriteUrl) {
            try {
              const img = document.createElement('img');
              img.className = 'slot-img';
              img.alt = label;
              img.decoding = 'async';
              img.loading = 'lazy';
              img.draggable = false;
              img.src = spriteUrl;
              img.addEventListener('error', () => {
                if (slot.contains(img)) slot.removeChild(img);
                slot.textContent = label;
              });
              slot.appendChild(img);
            } catch (_) {
              slot.textContent = label;
            }
          } else {
            slot.textContent = label;
          }
        }
      }

      function loadExisting() {
        const next = arrayFromStateTeam(readState());
        if (!arrayEquals(workingTeam, next)) workingTeam = next;
        updateSlots();
        updateGridSelection();
      }

      function pruneWorkingTeam() {
        const filtered = workingTeam.filter((uid) => entriesByUid.has(uid)).slice(0, MAX_TEAM);
        if (!arrayEquals(workingTeam, filtered)) {
          workingTeam = filtered;
          updateSlots();
          updateGridSelection();
        }
      }

      function getSelectedEntries() {
        return workingTeam.map((uid) => entriesByUid.get(uid)).filter(Boolean);
      }

      function getNameById(source) {
        const mon = getMonById(source);
        return (mon && mon.name) || 'Pokemon';
      }

      renderGrid();
      loadExisting();

      grid.addEventListener('click', (event) => {
        const btn = event.target.closest('.pokemon-btn');
        if (!btn) return;
        const uid = btn.dataset.uid;
        if (!uid) return;
        const index = workingTeam.indexOf(uid);
        if (index !== -1) {
          workingTeam.splice(index, 1);
        } else if (workingTeam.length < MAX_TEAM) {
          workingTeam.push(uid);
        } else {
          return;
        }
        updateSlots();
        updateGridSelection();
      });

      if (cancelBtn) cancelBtn.addEventListener('click', () => {
        window.location.href = 'rocket-select.html';
      });

      if (doneBtn) doneBtn.addEventListener('click', () => {
        const selected = getSelectedEntries();
        const finalTeamUids = selected.map((entry) => entry.uid);
        const finalTeamIds = selected.map((entry) => entry.id);
        const finalTeamNames = selected.map((entry) => entry.name || getNameById(entry));
        const finalTeamMembers = selected.map((entry) => ({
          uid: entry.uid,
          id: entry.id,
          level: entry.level,
          name: entry.name || getNameById(entry),
        }));
        writeState({
          selectedTeamMembers: finalTeamMembers,
          selectedTeamUids: finalTeamUids,
          selectedTeamIds: finalTeamIds,
          selectedTeam: finalTeamNames,
        });
        window.location.href = 'battle.html';
      });

      if (typeof subscribeState === 'function') {
        subscribeState((snapshot) => {
          const nextCollection = getCollection(snapshot);
          if (!collectionEquals(collection, nextCollection)) {
            collection = nextCollection;
            entriesByUid = buildEntriesMap(collection);
            renderGrid();
            pruneWorkingTeam();
          }
        });
      }

      if (window.UI && typeof window.UI.attachDragScroll === 'function') {
        window.UI.attachDragScroll(grid);
      }
    })();
  </script>
</body>
</html>

