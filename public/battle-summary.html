<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Battle Summary</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    .summary-page { display:flex; flex-direction:column; height:100%; }
    .summary-header { padding:16px; text-align:center; font-weight:800; border-bottom:1px solid #e5e5e5; background:#fff; }
    .summary-body { flex:1 1 auto; display:flex; align-items:center; justify-content:center; background:#fafafa; }
    .summary-card { width:min(92%, 420px); background:#fff; border:1px solid #e5e5e5; border-radius:12px; padding:20px; text-align:center; }
    .summary-title { font-size:20px; font-weight:900; margin-bottom:8px; }
    .summary-sub { color:#555; font-weight:600; margin-bottom:16px; }
    .summary-actions { padding:12px; border-top:1px solid #eee; background:#fff; }
    .hidden { display:none !important; }
    .reward-section { margin-top:20px; border-top:1px solid #eee; padding-top:16px; text-align:center; }
    .reward-title { font-size:16px; font-weight:800; margin-bottom:12px; color:#222; }
    .reward-grid { display:flex; flex-wrap:wrap; justify-content:center; gap:12px; }
    .reward-item { display:flex; flex-direction:column; align-items:center; gap:6px; padding:10px; width:92px; border:1px solid #e5e5e5; border-radius:12px; background:#fdfdfd; box-shadow:0 1px 2px rgba(15,23,42,0.04); }
    .reward-item img { width:64px; height:64px; object-fit:contain; image-rendering:pixelated; }
    .reward-name { font-size:12px; font-weight:700; color:#333; text-transform:capitalize; }
    .reward-amount { font-size:11px; font-weight:600; color:#555; }
    .reward-note { margin-top:10px; font-size:12px; color:#666; }
  </style>
  <script src="../dist/data/pokemon-types.js"></script>
  <script src="../dist/data/pokemon-moves-fast.js"></script>
  <script src="../dist/data/pokemon-moves-charged.js"></script>
  <script src="../dist/data/pokemon-species.js"></script>
  <script src="../dist/data/pokemon-stats.js"></script>
  <script src="../dist/data/pokemon-data.js"></script>
  <script src="../dist/system/collection.js"></script>
  <script src="../dist/rocket/rocket-teams.js"></script>
  <script src="../dist/system/shared.js"></script>
  <script src="../dist/system/saving.js"></script>
  <script src="../dist/items/item-data.js"></script>
</head>
<body>
  <div class="phone phone-column">
    <main class="summary-page" role="main">
      <div class="summary-header">Battle Summary</div>
      <div class="summary-body">
        <div class="summary-card" id="summaryCard">
          <div class="summary-title" id="summaryTitle">Battle Result</div>
          <div class="summary-sub" id="summaryDetail"></div>
          <div class="reward-section hidden" id="rewardSection">
            <div class="reward-title" id="rewardTitle">New Pokemon Unlocked!</div>
            <div class="reward-grid" id="rewardGrid"></div>
            <div class="reward-note" id="rewardNote">Added to your collection!</div>
          </div>
          <button class="btn btn-primary" id="backBtn" type="button">Return to Rocket Select</button>
        </div>
      </div>
    </main>
  </div>
  <script>
    (function(){
      function setText(el, text){ if (el) el.textContent = text; }
      const readState = (typeof window.readState === 'function')
        ? window.readState
        : function () {
            try {
              const raw = window.localStorage ? window.localStorage.getItem('pogo-pvp-state') : null;
              return raw ? JSON.parse(raw) : {};
            } catch (_) {
              return {};
            }
          };
      const writeState = (typeof window.writeState === 'function')
        ? window.writeState
        : function (patch) {
            if (!patch || Object(patch) !== patch) return;
            try {
              const current = readState();
              const next = Object.assign({}, current, patch);
              if (window.localStorage) {
                window.localStorage.setItem('pogo-pvp-state', JSON.stringify(next));
              }
            } catch (_) {}
          };
      let r = readState().lastBattleResult || null;
      const titleEl = document.getElementById('summaryTitle');
      const detailEl = document.getElementById('summaryDetail');
      const backBtn = document.getElementById('backBtn');
      const rewardSection = document.getElementById('rewardSection');
      const rewardGrid = document.getElementById('rewardGrid');
      const rewardTitle = document.getElementById('rewardTitle');
      const rewardNote = document.getElementById('rewardNote');
      const PD = window.PokemonData || {};
      const Collection = window.PlayerCollection || {};
      const MAX_REWARD_COUNT = 3;
      const ITEMS_KEY = 'playerItems';
      const ITEM_CAP = 9999;
      const itemCatalog = (() => {
        const data = window.ItemData;
        if (data && Array.isArray(data.list) && data.list.length) {
          return data;
        }
        console.warn('[Battle Summary] ItemData not available; using fallback definitions.');
        const fallbackList = [
          { key: 'rareCandy', name: 'Rare Candy', icon: 'https://archives.bulbagarden.net/media/upload/8/8d/Bag_Rare_Candy_Sprite.png', description: '', categories: ['candy'] },
          { key: 'fastTm', name: 'Fast TM', icon: 'https://archives.bulbagarden.net/media/upload/9/9a/Bag_TM_Normal_Sprite.png', description: '', categories: ['tm'] },
          { key: 'chargedTm', name: 'Charged TM', icon: 'https://archives.bulbagarden.net/media/upload/5/57/Bag_TM_Electric_Sprite.png', description: '', categories: ['tm'] },
          { key: 'eliteTm', name: 'Elite TM', icon: 'https://archives.bulbagarden.net/media/upload/6/64/Bag_TM_Fighting_Sprite.png', description: '', categories: ['tm'] },
          { key: 'sunStone', name: 'Sun Stone', icon: 'https://archives.bulbagarden.net/media/upload/a/ad/Bag_Sun_Stone_Sprite.png', description: '', categories: ['evolution'] },
          { key: 'moonStone', name: 'Moon Stone', icon: 'https://archives.bulbagarden.net/media/upload/a/ae/Bag_Moon_Stone_Sprite.png', description: '', categories: ['evolution'] },
          { key: 'fireStone', name: 'Fire Stone', icon: 'https://archives.bulbagarden.net/media/upload/8/86/Bag_Fire_Stone_Sprite.png', description: '', categories: ['evolution'] },
          { key: 'waterStone', name: 'Water Stone', icon: 'https://archives.bulbagarden.net/media/upload/3/3f/Bag_Water_Stone_Sprite.png', description: '', categories: ['evolution'] },
          { key: 'thunderStone', name: 'Thunder Stone', icon: 'https://archives.bulbagarden.net/media/upload/7/79/Bag_Thunder_Stone_Sprite.png', description: '', categories: ['evolution'] },
          { key: 'leafStone', name: 'Leaf Stone', icon: 'https://archives.bulbagarden.net/media/upload/e/eb/Bag_Leaf_Stone_Sprite.png', description: '', categories: ['evolution'] },
          { key: 'iceStone', name: 'Ice Stone', icon: 'https://archives.bulbagarden.net/media/upload/5/51/Bag_Ice_Stone_Sprite.png', description: '', categories: ['evolution'] },
          { key: 'shinyStone', name: 'Shiny Stone', icon: 'https://archives.bulbagarden.net/media/upload/4/45/Bag_Shiny_Stone_Sprite.png', description: '', categories: ['evolution'] },
          { key: 'duskStone', name: 'Dusk Stone', icon: 'https://archives.bulbagarden.net/media/upload/b/b2/Bag_Dusk_Stone_Sprite.png', description: '', categories: ['evolution'] },
          { key: 'dawnStone', name: 'Dawn Stone', icon: 'https://archives.bulbagarden.net/media/upload/7/70/Bag_Dawn_Stone_Sprite.png', description: '', categories: ['evolution'] }
        ];
        const fallbackByKey = {};
        fallbackList.forEach(function (item) {
          fallbackByKey[item.key] = item;
        });
        return {
          list: fallbackList,
          byKey: fallbackByKey,
          tmKeys: ['fastTm', 'chargedTm'],
          evolutionKeys: ['sunStone', 'moonStone', 'fireStone', 'waterStone', 'thunderStone', 'leafStone', 'iceStone', 'shinyStone', 'duskStone', 'dawnStone'],
        };
      })();

      const ITEM_INFO = itemCatalog.byKey || {};
      const TM_ITEMS = itemCatalog.tmKeys && itemCatalog.tmKeys.length ? itemCatalog.tmKeys.slice() : ['fastTm', 'chargedTm'];
      const EVOLUTION_ITEMS = itemCatalog.evolutionKeys && itemCatalog.evolutionKeys.length
        ? itemCatalog.evolutionKeys.slice()
        : ['sunStone', 'moonStone', 'fireStone', 'waterStone', 'thunderStone', 'leafStone', 'iceStone', 'shinyStone', 'duskStone', 'dawnStone'];

      function normalizeStoredItemValue(value) {
        const num = Math.floor(Number(value));
        if (!Number.isFinite(num)) return 0;
        if (num < 0) return 0;
        if (num > ITEM_CAP) return ITEM_CAP;
        return num;
      }

      function sanitizeItemValue(value) {
        const num = Math.floor(Number(value));
        if (!Number.isFinite(num) || num <= 0) return 0;
        if (num > ITEM_CAP) return ITEM_CAP;
        return num;
      }

      function pickRandomItem(list) {
        if (!Array.isArray(list) || !list.length) return null;
        const idx = Math.floor(Math.random() * list.length);
        return list[idx];
      }

      function readItemCounts() {
        const snapshot = readState();
        const raw = snapshot && snapshot[ITEMS_KEY];
        const result = {};
        if (raw && typeof raw === 'object') {
          Object.keys(raw).forEach(function (key) {
            const value = normalizeStoredItemValue(raw[key]);
            if (value > 0) result[key] = value;
          });
        }
        return result;
      }

      function writeItemCounts(map) {
        const normalized = {};
        if (map && typeof map === 'object') {
          Object.keys(map).forEach(function (key) {
            const value = normalizeStoredItemValue(map[key]);
            if (value > 0) normalized[key] = value;
          });
        }
        const payload = {};
        payload[ITEMS_KEY] = normalized;
        writeState(payload);
      }

      function incrementItemCounts(updates) {
        if (!updates || typeof updates !== 'object') return [];
        const base = readItemCounts();
        const next = Object.assign({}, base);
        const granted = [];
        Object.keys(updates).forEach(function (key) {
          const amount = sanitizeItemValue(updates[key]);
          if (!amount) return;
          const current = normalizeStoredItemValue(next[key]);
          const total = Math.min(ITEM_CAP, current + amount);
          const delta = total - current;
          if (delta <= 0) return;
          next[key] = total;
          granted.push({ key: key, amount: delta });
        });
        if (granted.length) {
          writeItemCounts(next);
        }
        return granted;
      }

      const DEFAULT_ROCKET_STAGES = [
        { id: 'grunt-male', team: [ { level: 5 }, { level: 5 }, { level: 7 } ] },
        { id: 'grunt-female', team: [ { level: 7 }, { level: 7 }, { level: 9 } ] },
        { id: 'cliff', team: [ { level: 40 }, { level: 42 }, { level: 43 } ] },
        { id: 'arlo', team: [ { level: 39 }, { level: 41 }, { level: 43 } ] },
        { id: 'sierra', team: [ { level: 38 }, { level: 40 }, { level: 42 } ] },
        { id: 'giovanni', team: [ { level: 45 }, { level: 47 }, { level: 50 } ] },
      ];

      function clampRewardLevel(value) {
        let n = Number(value);
        if (!Number.isFinite(n)) return 20;
        if (n < 1) n = 1;
        if (n > 50) n = 50;
        return Math.round(n * 2) / 2;
      }

      function findRocketStage() {
        if (!r) return null;
        const stages = Array.isArray(window.RocketTeams) ? window.RocketTeams : [];
        const fallbackStages = DEFAULT_ROCKET_STAGES;
        const numericIndex = Number(r && r.stageIndex);
        const stageId = r && r.stageId;

        function hasTeam(candidate) {
          return candidate && Array.isArray(candidate.team) && candidate.team.length;
        }

        let stage = Number.isFinite(numericIndex) && numericIndex >= 0 && numericIndex < stages.length
          ? stages[numericIndex]
          : null;

        if (!hasTeam(stage) && typeof window.getRocketStageByIndex === 'function' && Number.isFinite(numericIndex)) {
          try {
            const candidate = window.getRocketStageByIndex(numericIndex);
            if (hasTeam(candidate)) stage = candidate;
          } catch (_) {}
        }

        if (!hasTeam(stage) && stageId && typeof window.getRocketStageById === 'function') {
          try {
            const candidate = window.getRocketStageById(stageId);
            if (hasTeam(candidate)) stage = candidate;
          } catch (_) {}
        }

        if (!hasTeam(stage) && stageId && stages.length) {
          stage = stages.find(function (entry) { return entry && entry.id === stageId; }) || stage;
        }

        if (!hasTeam(stage) && stageId) {
          stage = fallbackStages.find(function (entry) { return entry && entry.id === stageId; }) || stage;
        }

        if (!hasTeam(stage) && Number.isFinite(numericIndex) && numericIndex >= 0) {
          stage = fallbackStages[numericIndex] || stage;
        }

        return hasTeam(stage) ? stage : null;
      }

      function resolveRewardLevel() {
        const stage = findRocketStage();
        if (stage && Array.isArray(stage.team) && stage.team.length) {
          const member = stage.team[0];
          if (member && member.level != null) {
            return clampRewardLevel(member.level);
          }
        }
        if (r && r.firstOpponentLevel != null) {
          return clampRewardLevel(r.firstOpponentLevel);
        }
        return 20;
      }
      const rewardLevel = resolveRewardLevel();
      function getEligibleSpeciesPool() {
        const list = PD && Array.isArray(PD.all) ? PD.all : [];
        if (!list.length) return [];
        function computeMaxCp(species) {
          if (!species) return null;
          if (Number.isFinite(species.maxCp)) return Number(species.maxCp);
          if (species.baseStats && typeof PD.calcGoCp === 'function') {
            try { return Number(PD.calcGoCp(species.baseStats)); } catch (_) { return null; }
          }
          return null;
        }
        const mapped = list.map(function (species, index) {
          return { species: species, cp: computeMaxCp(species), index: index };
        }).filter(function (entry) {
          return entry.species && Number.isFinite(entry.species.id);
        });
        mapped.sort(function (a, b) {
          const cpA = Number.isFinite(a.cp) ? a.cp : Infinity;
          const cpB = Number.isFinite(b.cp) ? b.cp : Infinity;
          if (cpA !== cpB) return cpA - cpB;
          return a.index - b.index;
        });
        if (typeof console !== 'undefined') {
          const debugRows = mapped.map(function (entry) {
            return { name: entry.species.name || entry.species.speciesName || ('#' + entry.species.id), maxCp: entry.cp };
          });
          if (console.table) console.table(debugRows, ['name', 'maxCp']); else console.log('[Battle Summary] Eligible species pool', debugRows);
        }
        return mapped.map(function (entry) { return entry.species; });
      }
      function pickRandomSpecies(count) {
        if (!Number.isFinite(count) || count <= 0) return [];
        const pool = getEligibleSpeciesPool();
        if (!pool.length) return [];
        const stage = findRocketStage();
        const stages = Array.isArray(window.RocketTeams) && window.RocketTeams.length
          ? window.RocketTeams
          : DEFAULT_ROCKET_STAGES;
        const stageCount = stages.length || 1;
        const numericIndex = Number(r && r.stageIndex);
        function computeDifficulty(entry) {
          if (!entry || !Array.isArray(entry.team) || !entry.team.length) return 0;
          let maxLevel = 0;
          for (let i = 0; i < entry.team.length; i++) {
            const member = entry.team[i];
            const lvl = Number(member && member.level);
            if (Number.isFinite(lvl) && lvl > maxLevel) maxLevel = lvl;
          }
          return maxLevel;
        }
        const rankedStages = stages.map(function (entry, idx) {
          return { entry: entry, idx: idx, score: computeDifficulty(entry) };
        }).sort(function (a, b) {
          if (a.score === b.score) return a.idx - b.idx;
          return a.score - b.score;
        });
        let targetEntry = stage || (Number.isFinite(numericIndex) && numericIndex >= 0 && numericIndex < stages.length ? stages[numericIndex] : null);
        let normalizedIndex = -1;
        if (targetEntry) {
          const targetId = targetEntry.id;
          normalizedIndex = rankedStages.findIndex(function (item) {
            return item.entry && item.entry.id === targetId;
          });
        }
        if (normalizedIndex < 0) {
          normalizedIndex = Number.isFinite(numericIndex) && numericIndex >= 0 ? Math.min(numericIndex, rankedStages.length - 1) : 0;
        }
        if (normalizedIndex < 0) normalizedIndex = 0;
        if (normalizedIndex >= rankedStages.length) normalizedIndex = rankedStages.length - 1;
        const segmentSize = Math.max(1, Math.ceil(pool.length / rankedStages.length));
        let start = normalizedIndex * segmentSize;
        if (start >= pool.length) start = pool.length - segmentSize;
        if (start < 0) start = 0;
        let end = start + segmentSize;
        if (end > pool.length) end = pool.length;
        const segment = pool.slice(start, end);
        if (!segment.length) return [];
        const max = Math.min(segment.length, Math.floor(count));
        const used = new Set();
        const picks = [];
        while (picks.length < max && used.size < segment.length) {
          const idx = Math.floor(Math.random() * segment.length);
          const candidate = segment[idx];
          if (!candidate || used.has(candidate.id)) continue;
          used.add(candidate.id);
          picks.push(candidate);
        }
        return picks;
      }
      function awardPokemon(speciesList) {
        const createPokemon = Collection && typeof Collection.createPokemon === 'function'
          ? Collection.createPokemon
          : null;
        if (!Array.isArray(speciesList) || !speciesList.length) return [];
        const results = [];
        function appendToCollection(entry) {
          if (!entry || !Number.isFinite(entry.id)) return null;
          const state = readState();
          const list = Array.isArray(state.playerPokemon) ? state.playerPokemon.slice() : [];
          if (entry.uid && list.some(function (item) { return item && item.uid === entry.uid; })) {
            return entry;
          }
          list.push(entry);
          try {
            writeState({ playerPokemon: list });
          } catch (_) {}
          return entry;
        }
        for (let i = 0; i < speciesList.length; i++) {
          const species = speciesList[i];
          if (!species || !Number.isFinite(species.id)) continue;
          let created = null;
          if (createPokemon) {
            try {
              created = createPokemon({
                id: Number(species.id),
                name: species.name,
                level: rewardLevel
              });
            } catch (_) {}
          }
          if (created && created.uid) {
            appendToCollection(created);
            results.push({
              id: Number(species.id),
              name: species.name || null,
              uid: created.uid,
              level: rewardLevel
            });
            continue;
          }
          const fallbackUid = 'pk_reward_' + Date.now().toString(36) + '_' + i + '_' + Math.random().toString(36).slice(2, 6);
          const fallbackEntry = appendToCollection({
            uid: fallbackUid,
            id: Number(species.id),
            level: rewardLevel,
            name: species.name || null,
            createdAt: Date.now()
          });
          results.push({
            id: Number(species.id),
            name: species.name || null,
            uid: fallbackEntry && fallbackEntry.uid ? fallbackEntry.uid : fallbackUid,
            level: rewardLevel
          });
        }
        return results;
      }

      function grantItemRewards(level) {
        const updates = {};
        const levelNumber = Number(level);
        const candyAmount = sanitizeItemValue(levelNumber > 0 ? Math.max(1, Math.round(levelNumber)) : 1);
        if (candyAmount > 0) {
          updates.rareCandy = candyAmount;
        }
        const tmKey = pickRandomItem(TM_ITEMS);
        if (tmKey) {
          updates[tmKey] = (updates[tmKey] || 0) + 1;
        }
        const evoKey = pickRandomItem(EVOLUTION_ITEMS);
        if (evoKey) {
          updates[evoKey] = (updates[evoKey] || 0) + 1;
        }
        const granted = incrementItemCounts(updates);
        return Array.isArray(granted) ? granted : [];
      }

      function renderRewards(list, options) {
        if (!rewardGrid) return;
        const filteredItems = options && Array.isArray(options.items)
          ? options.items.map(function (entry) {
              if (!entry || !entry.key) return null;
              const amount = sanitizeItemValue(entry.amount != null ? entry.amount : entry.count);
              if (!amount) return null;
              return { key: entry.key, amount: amount };
            }).filter(Boolean)
          : [];
        const hasPokemon = Array.isArray(list) && list.length > 0;
        const hasItems = filteredItems.length > 0;
        if (!hasPokemon && !hasItems) return;
        if (rewardSection && rewardSection.classList) {
          rewardSection.classList.remove('hidden');
        } else if (rewardSection) {
          rewardSection.style.display = 'block';
        }
        rewardGrid.textContent = '';
        const alreadyClaimed = options && options.alreadyClaimed;
        if (rewardTitle) {
          if (hasPokemon) setText(rewardTitle, alreadyClaimed ? 'Unlocked Pokemon' : 'New Pokemon Unlocked!');
          else setText(rewardTitle, alreadyClaimed ? 'Rewards Claimed' : 'Rewards Earned!');
        }
        if (rewardNote) {
          if (hasPokemon && hasItems) setText(rewardNote, alreadyClaimed ? 'Rewards already collected.' : 'Added to your collection and item bag!');
          else if (hasPokemon) setText(rewardNote, alreadyClaimed ? 'Already added to your collection.' : 'Added to your collection!');
          else setText(rewardNote, alreadyClaimed ? 'Already stored in your item bag.' : 'Stored in your item bag!');
        }
        if (hasPokemon) {
          for (let i = 0; i < list.length; i++) {
            const info = list[i];
            if (!info || !Number.isFinite(info.id)) continue;
            const wrapper = document.createElement('div');
            wrapper.className = 'reward-item';
            const mon = PD && typeof PD.getPokemonById === 'function' ? PD.getPokemonById(info.id) : null;
            const displayName = info.name || (mon && mon.name) || ('#' + info.id);
            let spriteUrl = '';
            if (PD && typeof PD.getForwardSpriteUrl === 'function') {
              try {
                spriteUrl = PD.getForwardSpriteUrl(mon || displayName);
              } catch (_) {}
            }
            if (!spriteUrl && mon && mon.sprite) {
              spriteUrl = mon.sprite;
            }
            if (spriteUrl) {
              const img = document.createElement('img');
              img.alt = displayName;
              img.src = spriteUrl;
              wrapper.appendChild(img);
            }
            const label = document.createElement('div');
            label.className = 'reward-name';
            label.textContent = displayName;
            wrapper.appendChild(label);
            rewardGrid.appendChild(wrapper);
          }
        }
        if (hasItems) {
          for (let i = 0; i < filteredItems.length; i++) {
            const entry = filteredItems[i];
            const meta = ITEM_INFO[entry.key] || { name: entry.key, icon: '' };
            const wrapper = document.createElement('div');
            wrapper.className = 'reward-item';
            if (meta.icon) {
              const img = document.createElement('img');
              img.alt = meta.name || entry.key;
              img.src = meta.icon;
              wrapper.appendChild(img);
            }
            const label = document.createElement('div');
            label.className = 'reward-name';
            label.textContent = meta.name || entry.key;
            wrapper.appendChild(label);
            const amountLabel = document.createElement('div');
            amountLabel.className = 'reward-amount';
            amountLabel.textContent = 'x' + entry.amount;
            wrapper.appendChild(amountLabel);
            rewardGrid.appendChild(wrapper);
          }
        }
      }
      let title = 'Battle Result';
      let detail = '';
      if (r && r.outcome) {
        if (r.outcome === 'win') title = 'You Won!';
        else if (r.outcome === 'lose') title = 'You Lost';
        else if (r.outcome === 'forfeit') title = 'You Forfeited';
        else if (r.outcome === 'tie') title = "It's a Tie!";
        const vs = r.opponent ? `Opponent: ${r.opponent}` : '';
        detail = vs;
      } else {
        detail = 'No recent battle information.';
      }
      setText(titleEl, title);
      setText(detailEl, detail);
      if (r && r.outcome === 'win') {
        const existing = Array.isArray(r.rewardPokemon)
          ? r.rewardPokemon.filter(function (item) { return item && Number.isFinite(item.id); })
          : [];
        const storedItems = Array.isArray(r.rewardItems)
          ? r.rewardItems.map(function (entry) {
              if (!entry || !entry.key) return null;
              const amount = sanitizeItemValue(entry.amount != null ? entry.amount : entry.count);
              if (!amount) return null;
              return { key: entry.key, amount: amount };
            }).filter(Boolean)
          : [];
        if (r.rewardClaimed) {
          if (existing.length || storedItems.length) {
            renderRewards(existing, { alreadyClaimed: true, items: storedItems });
          }
        } else {
          const picks = pickRandomSpecies(MAX_REWARD_COUNT);
          const awarded = awardPokemon(picks);
          const grantedItems = grantItemRewards(rewardLevel);
          const hasRewards = awarded.length > 0 || grantedItems.length > 0;
          if (hasRewards) {
            renderRewards(awarded, { alreadyClaimed: false, items: grantedItems });
          }
          const nextResult = Object.assign({}, r || {}, {
            rewardClaimed: true,
            rewardPokemon: awarded,
            rewardItems: grantedItems
          });
          writeState({ lastBattleResult: nextResult });
          r = nextResult;
        }
      }
      function goBack(){ window.location.href = 'rocket-select.html'; }
      if (backBtn) backBtn.addEventListener('click', goBack);
    })();
  </script>
</body>
</html>









