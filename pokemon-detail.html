<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Battle!</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    /* Page-specific styles to emulate a Pokemon Go-like detail view */
    .detail-wrap { display: flex; flex-direction: column; height: 100%; background: #f5f5f7; }
    /* Make entire page (phone) the scroll container for this view */
    .phone.phone-column { overflow-y: auto; }

    /* Top card with portrait (no level arc) */
    .top-card {
      position: relative;
      background: linear-gradient(180deg, #89c4ff 0%, #ffffff 100%);
      padding: 24px 16px 64px;
      border-bottom: 1px solid #e5e5e5;
    }
    .cp-label { text-align: center; font-weight: 700; letter-spacing: 0.5px; color: #000; }
    .cp-value { text-align: center; font-size: 28px; font-weight: 800; margin-top: 6px; color: #000; }
    /* Put CP label and value on one line */
    .cp-row { display: flex; align-items: baseline; justify-content: center; gap: 6px; }
    .cp-row .cp-value { margin-top: 0; }
    /* Reserve vertical space for the portrait so name/meta don't crowd CP */
    .portrait-spacer { height: var(--portrait-spacer, 148px); }
    .portrait {
      position: absolute;
      left: 50%;
      /* top set dynamically to midpoint between CP and name */
      transform: translate(-50%, -50%);
      margin: 0;
      width: auto; height: auto;
      display: flex; align-items: center; justify-content: center;
      background: transparent; border: none; border-radius: 0; box-shadow: none;
      z-index: 1;
    }
    /* Sprite inside portrait */
    .portrait img { max-width: 100%; max-height: 100%; object-fit: contain; image-rendering: auto; transform: scale(2); transform-origin: center center; }
    .name-row { margin-top: 12px; text-align: center; font-size: 22px; font-weight: 800; color: #000; }
    .meta-row { margin-top: 6px; text-align: center; color: #1f2d3d; font-size: 13px; opacity: 0.85; }

    /* Type chips */
    .types { margin-top: 10px; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }
    .chip { padding: 4px 10px; border-radius: 999px; font-weight: 700; font-size: 12px; color: #fff; }
    .t-normal{ background:#a8a77a; } .t-fire{ background:#ee8130; } .t-water{ background:#6390f0; }
    .t-electric{ background:#f7d02c; color:#212121; } .t-grass{ background:#7ac74c; }
    .t-ice{ background:#96d9d6; color:#212121; } .t-fighting{ background:#c22e28; }
    .t-poison{ background:#a33ea1; } .t-ground{ background:#e2bf65; color:#212121; }
    .t-flying{ background:#a98ff3; } .t-psychic{ background:#f95587; }
    .t-bug{ background:#a6b91a; } .t-rock{ background:#b6a136; }
    .t-ghost{ background:#735797; } .t-dragon{ background:#6f35fc; }
    .t-dark{ background:#705746; } .t-steel{ background:#b7b7ce; color:#212121; }
    .t-fairy{ background:#d685ad; }

    /* Content sections */
    .level-row { display:flex; align-items:center; gap: 12px; margin-bottom: 12px; }
    .level-input { flex: 1 1 auto; padding: 8px 12px; font-size: 16px; border: 1px solid #d0d0d0; border-radius: 12px; background: #fff; color: #111; box-shadow: inset 0 1px 2px rgba(0,0,0,0.06); }
    .level-input:focus { outline: none; border-color: #007aff; box-shadow: 0 0 0 2px rgba(0,122,255,0.15); }
    .save-feedback { margin-top: 10px; text-align: center; font-size: 13px; font-weight: 600; color: #2ecc71; min-height: 18px; }
    .save-feedback[data-error='1'] { color: #e74c3c; }
    .btn-danger { background:#e74c3c; border:1px solid #c0392b; color:#fff; }
    .btn-danger:hover { filter: brightness(0.95); }
    .btn-danger:disabled { background:#f2b4aa; border-color:#d98880; cursor:not-allowed; }
    .btn-secondary { background:#fff; border:1px solid #d0d7e2; color:#1f2d3d; }
    .btn-secondary:hover { background:#f6f8fb; }
    .btn-secondary:disabled { opacity:0.6; cursor:not-allowed; }
    .confirm-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.45); display:none; align-items:center; justify-content:center; padding:16px; z-index:1000; }
    .confirm-overlay.is-open { display:flex; }
    .confirm-dialog { background:#fff; border-radius:16px; padding:24px 20px; box-shadow:0 12px 32px rgba(0,0,0,0.18); max-width:320px; width:100%; text-align:center; }
    .confirm-message { font-weight:700; color:#1f2d3d; }
    .confirm-actions { display:flex; gap:12px; margin-top:20px; justify-content:center; }
    .confirm-actions .btn { flex:1 1 auto; }
    /* Content now flows; parent handles scrolling */
    .content { flex: 1 1 auto; overflow: visible; padding: 12px; background:#f5f5f7; }
    .card { background:#fff; border:1px solid #e6e6e6; border-radius: 14px; padding: 12px; margin-bottom: 12px; }
    .row { display:flex; align-items:center; justify-content:space-between; gap: 10px; }
    .label { color:#666; font-weight:700; font-size:12px; text-transform:uppercase; letter-spacing:0.4px; }
    .value { font-weight:800; color:#111; }

    /* HP bar */
    .hp-bar { height: 10px; background:#eee; border-radius: 999px; overflow: hidden; margin-top: 6px; }
    .hp-fill { height:100%; background:linear-gradient(90deg,#38d39f,#00b894); width: 50%; }

    /* IV-like stats */
    .iv { display:grid; grid-template-columns: repeat(3,1fr); gap:10px; margin-top: 8px; }
    .iv .stat { text-align:center; }
    .iv .stat .bar { height: 8px; border-radius: 6px; background:#eee; overflow: hidden; }
    .iv .stat .fill { height: 100%; background:#007aff; width: 80%; }

    /* Moves list */
    .moves .move { display:flex; align-items:center; justify-content:space-between; padding: 10px 0; border-bottom:1px solid #f0f0f0; }
    .moves .move:last-child { border-bottom:none; }
    .moves .left { display:flex; align-items:center; gap:8px; }
    .dot { width:10px; height:10px; border-radius:50%; background:#007aff; }
    .power { font-weight:800; }

    /* close button styles are shared in styles.css */
    /* Stats layout: four numbers in a single row with grey labels below */
    .stats-row { display:grid; grid-template-columns: repeat(4, 1fr); gap: 10px; text-align: center; margin-top: 8px; }
    .stat-col .value { font-weight: 800; }
  </style>
  </head>
<body>
  <div class="phone phone-column">
    <div class="detail-wrap">
      <div class="top-card">
        <div class="cp-row">
          <div class="cp-label">CP</div>
          <div class="cp-value" id="cpValue">1234</div>
        </div>
        <div class="portrait-spacer" aria-hidden="true"></div>
        <div class="portrait" id="portrait" aria-label="Pokémon portrait"></div>
        <div class="name-row" id="nameRow">Pokemon</div>
        <div class="meta-row" id="metaRow">Lvl 20</div>
        <div class="types" id="typeChips"></div>
      </div>

      <div class="content" id="content">
        <div class="card">
          <div class="label">Stats</div>
          <div class="stats-row">
            <div class="stat-col">
              <div class="value" id="statHp">—</div>
              <div class="label">HP</div>
            </div>
            <div class="stat-col">
              <div class="value" id="statAtk">—</div>
              <div class="label">Attack</div>
            </div>
            <div class="stat-col">
              <div class="value" id="statDef">—</div>
              <div class="label">Defense</div>
            </div>
            <div class="stat-col">
              <div class="value" id="statSpd">—</div>
              <div class="label">Speed</div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="label">IVs</div>
          <div class="stats-row">
            <div class="stats-col">
              <div class="value" id="ivHp">—</div>
              <div class="label">HP</div>
            </div>
            <div class="stats-col">
              <div class="value" id="ivAtk">—</div>
              <div class="label">Attack</div>
            </div>
            <div class="stats-col">
              <div class="value" id="ivDef">—</div>
              <div class="label">Defense</div>
            </div>
            <div class="stats-col">
              <div class="value" id="ivSpd">—</div>
              <div class="label">Speed</div>
            </div>
          </div>
        </div>

        <div class="card moves">
          <div class="label" style="margin-bottom:6px;">Moves</div>
          <div class="move">
            <div class="left"><div class="dot"></div><div class="value" id="fastMove">Fast Move</div></div>
            <div class="power" id="fastPower">8</div>
          </div>
          <div class="move">
            <div class="left"><div class="dot"></div><div class="value" id="chargeMove1">Charge Move 1</div></div>
            <div class="power" id="chargePower1">70</div>
          </div>
          <div class="move">
            <div class="left"><div class="dot"></div><div class="value" id="chargeMove2">Charge Move 2</div></div>
            <div class="power" id="chargePower2">100</div>
          </div>
        </div>

        <div class="card">
          <div class="row level-row">
            <label class="label" for="levelInput">Level</label>
            <input class="level-input" id="levelInput" type="number" inputmode="decimal" min="1" max="50" step="0.5" value="20">
          </div>
          <button class="btn btn-primary" id="savePokemonBtn" type="button" style="width:100%">Save Pokemon</button>
          <div class="save-feedback" id="saveFeedback" aria-live="polite"></div>
        </div>

        <div class="card">
          <button class="btn btn-primary" id="powerBtn" type="button" style="width:100%">Power Up</button>
        </div>

        <div class="card" style="display:none;">
          <button class="btn btn-danger" id="releasePokemonBtn" type="button" style="width:100%">Release Pokemon</button>
        </div>
      </div>

      <div class="confirm-overlay" id="releaseConfirmOverlay" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="confirm-dialog">
          <div class="confirm-message">Release this Pokemon from your collection?</div>
          <div class="confirm-actions">
            <button class="btn btn-secondary" id="releaseCancelBtn" type="button">No</button>
            <button class="btn btn-danger" id="releaseConfirmBtn" type="button">Yes, release</button>
          </div>
        </div>
      </div>

      <div class="bottom-close">
        <button class="close-btn" id="closeBtn" type="button" aria-label="Close">&times;</button>
      </div>
    </div>
  </div>
  <script src="pokemon-types.js"></script>
  <script src="pokemon-moves-fast.js"></script>
  <script src="pokemon-moves-charged.js"></script>
  <script src="pokemon-species.js"></script>
  <script src="pokemon-stats.js"></script>
  <script src="pokemon-data.js"></script>
  <script src="shared.js"></script>
  <script src="collection.js"></script>
    <script>
    (function(){
      const page = document.querySelector('.phone.phone-column');
      if (page && window.UI && typeof window.UI.attachDragScroll === 'function') {
        window.UI.attachDragScroll(page);
      }

      const store = window.AppState || null;
      const STORAGE_KEY = 'pogo-pvp-state';

      const readState = (typeof window.readState === 'function')
        ? window.readState
        : function () {
          if (store && typeof store.read === 'function') return store.read();
          if (store && typeof store.all === 'function') return store.all();
          try {
            const raw = window.localStorage ? window.localStorage.getItem(STORAGE_KEY) : null;
            return raw ? JSON.parse(raw) : {};
          } catch (_) {
            return {};
          }
        };

      const writeState = (typeof window.writeState === 'function')
        ? window.writeState
        : function (patch) {
          if (!patch || Object(patch) !== patch) return;
          if (store && typeof store.write === 'function') { store.write(patch); return; }
          if (store && typeof store.merge === 'function') { store.merge(patch); return; }
          if (store && typeof store.set === 'function') {
            Object.keys(patch).forEach((key) => store.set(key, patch[key]));
            return;
          }
          try {
            const next = Object.assign({}, readState(), patch);
            if (window.localStorage) {
              window.localStorage.setItem(STORAGE_KEY, JSON.stringify(next));
            }
          } catch (_) {}
        };

      function sanitizeCollectionEntry(entry) {
        if (!entry || typeof entry !== 'object') return null;
        const uid = typeof entry.uid === 'string' && entry.uid ? entry.uid : null;
        const id = Number(entry.id);
        const level = Number(entry.level);
        if (!uid || Number.isNaN(id) || Number.isNaN(level)) return null;
        const normalized = {
          uid,
          id,
          level,
          name: typeof entry.name === 'string' ? entry.name : null,
          createdAt: Number.isFinite(entry.createdAt) ? Number(entry.createdAt) : null,
        };
        if (entry.shiny != null) normalized.shiny = entry.shiny;
        if (entry.ivHp != null) normalized.ivHp = entry.ivHp;
        if (entry.ivAttack != null) normalized.ivAttack = entry.ivAttack;
        if (entry.ivDefense != null) normalized.ivDefense = entry.ivDefense;
        if (entry.ivs && typeof entry.ivs === 'object') {
          normalized.ivs = {
            hp: entry.ivs.hp,
            attack: entry.ivs.attack,
            defense: entry.ivs.defense,
          };
        }
        return normalized;
      }

      function getCollection(state) {
        const source = state && Array.isArray(state.playerPokemon) ? state.playerPokemon : [];
        const clean = [];
        for (let i = 0; i < source.length; i++) {
          const entry = sanitizeCollectionEntry(source[i]);
          if (entry) clean.push(entry);
        }
        return clean;
      }

      const state = readState();
      const view = state && typeof state === 'object' ? (state.viewPokemon || {}) : {};
      const PD = window.PokemonData || {};

      const collection = getCollection(state);
      let activeUid = typeof view.uid === 'string' && view.uid ? view.uid : '';
      let existingEntry = activeUid ? collection.find((item) => item.uid === activeUid) : null;

      const fallbackMon = (Array.isArray(PD.all) && PD.all.length) ? PD.all[0] : { id: 1, name: 'Pokemon', types: ['normal'], fastMoves: [], chargedMoves: [] };
      const id = Number(view.id || (existingEntry ? existingEntry.id : fallbackMon.id)) || fallbackMon.id;
      const overrides = existingEntry && typeof existingEntry === 'object' ? existingEntry : null;
      const mon = (PD.getPokemonById ? PD.getPokemonById(id, overrides) : null) || (PD.byId && PD.byId.get ? PD.byId.get(id) : null) || fallbackMon;
      const name = (mon && mon.name) || (view.name || fallbackMon.name);
      const types = Array.isArray(mon.types) ? mon.types : [];
      const isShiny = !!(mon && mon.shiny);
      const fallbackStats = { hp: 100, attack: 50, defense: 50, speed: 50 };

      let currentLevel = 20;
      function formatLevel(level) {
        const rounded = Math.round(level);
        if (Math.abs(level - rounded) < 0.01) return String(rounded);
        return level.toFixed(1).replace(/0+$/, '').replace(/\.$/, '');
      }

      function sanitizeLevel(value, fallback) {
        const base = typeof fallback === 'number' ? fallback : currentLevel || 20;
        let n = parseFloat(value);
        if (Number.isNaN(n)) n = base;
        n = Math.max(1, Math.min(n, 50));
        n = Math.round(n * 2) / 2;
        return n;
      }

      const initialLevel = existingEntry ? existingEntry.level : (view && view.level != null ? Number(view.level) : 20);
      currentLevel = sanitizeLevel(initialLevel, 20);

      const $ = (id) => document.getElementById(id);
      const cpEl = $('cpValue');
      const nameEl = $('nameRow');
      const metaRowEl = $('metaRow');
      const hpEl = $('statHp');
      const atkEl = $('statAtk');
      const defEl = $('statDef');
      const spdEl = $('statSpd');
      const ivHpEl = $('ivHp');
      const ivAtkEl = $('ivAtk');
      const ivDefEl = $('ivDef');
      const ivSpdEl = $('ivSpd');
      const levelInput = $('levelInput');
      const saveBtn = $('savePokemonBtn');
      const feedbackEl = $('saveFeedback');
      const powerBtn = $('powerBtn');
      const releaseBtn = $('releasePokemonBtn');
      const releaseCard = releaseBtn ? releaseBtn.closest('.card') : null;
      const releaseOverlay = $('releaseConfirmOverlay');
      const releaseConfirmBtn = $('releaseConfirmBtn');
      const releaseCancelBtn = $('releaseCancelBtn');
      const typeWrap = $('typeChips');
      let updateSaveLabel = () => {};
      let pendingReleaseUid = '';
      let releaseHandler = null;
      const backBtn = $('closeBtn');
      const fastMoveEl = $('fastMove');
      const fastPowerEl = $('fastPower');
      const chMove1El = $('chargeMove1');
      const chPower1El = $('chargePower1');
      const chMove2El = $('chargeMove2');
      const chPower2El = $('chargePower2');

      if (nameEl) nameEl.textContent = name;

      const fastId = mon && Array.isArray(mon.fastMoves) && mon.fastMoves[0];
      const fastDef = fastId && PD.FAST_MOVES_BY_ID ? PD.FAST_MOVES_BY_ID[fastId] : null;
      const chargedIds = (mon && Array.isArray(mon.chargedMoves)) ? mon.chargedMoves.slice(0, 2) : [];
      const ch1Def = chargedIds[0] && PD.CHARGED_MOVES_BY_ID ? PD.CHARGED_MOVES_BY_ID[chargedIds[0]] : null;
      const ch2Def = chargedIds[1] && PD.CHARGED_MOVES_BY_ID ? PD.CHARGED_MOVES_BY_ID[chargedIds[1]] : null;

      if (fastMoveEl) fastMoveEl.textContent = (fastDef && fastDef.name) || 'Fast Move';
      if (fastPowerEl) fastPowerEl.textContent = (fastDef && fastDef.power != null) ? fastDef.power : '';
      if (chMove1El) chMove1El.textContent = (ch1Def && ch1Def.name) || 'Charge Move 1';
      if (chPower1El) chPower1El.textContent = (ch1Def && ch1Def.power != null) ? ch1Def.power : '';
      if (chMove2El) chMove2El.textContent = (ch2Def && ch2Def.name) || 'Charge Move 2';
      if (chPower2El) chPower2El.textContent = (ch2Def && ch2Def.power != null) ? ch2Def.power : '';

      if (ivHpEl) ivHpEl.textContent = (existingEntry && Number.isFinite(existingEntry.ivHp)) ? String(existingEntry.ivHp) : '—';
      if (ivAtkEl) ivAtkEl.textContent = (existingEntry && Number.isFinite(existingEntry.ivAttack)) ? String(existingEntry.ivAttack) : '—';
      if (ivDefEl) ivDefEl.textContent = (existingEntry && Number.isFinite(existingEntry.ivDefense)) ? String(existingEntry.ivDefense) : '—';
      // Average of all other IVs  
      if (ivSpdEl) ivSpdEl.textContent = (existingEntry && Number.isFinite(existingEntry.ivHp) && Number.isFinite(existingEntry.ivAttack) && Number.isFinite(existingEntry.ivDefense))
        ? String(Math.round((existingEntry.ivHp + existingEntry.ivAttack + existingEntry.ivDefense) / 3))
        : '—'; 

      if (typeWrap) {
        typeWrap.innerHTML = '';
        types.forEach((t) => {
          const chip = document.createElement('div');
          chip.className = 'chip t-' + t;
          chip.textContent = String(t || '').toUpperCase();
          typeWrap.appendChild(chip);
        });
      }

      (function updateTopGradient(){
        const COLORS = {
          normal:'#a8a77a', fire:'#ee8130', water:'#6390f0', electric:'#f7d02c', grass:'#7ac74c', ice:'#96d9d6',
          fighting:'#c22e28', poison:'#a33ea1', ground:'#e2bf65', flying:'#a98ff3', psychic:'#f95587', bug:'#a6b91a',
          rock:'#b6a136', ghost:'#735797', dragon:'#6f35fc', dark:'#705746', steel:'#b7b7ce', fairy:'#d685ad'
        };
        const topCard = document.querySelector('.top-card');
        const primary = (types && types[0] || '').toLowerCase();
        const base = COLORS[primary];
        if (topCard && base) {
          topCard.style.background = `linear-gradient(180deg, ${base} 0%, #ffffff 100%)`;
        }
      })();

      function computeStats(level) {
        try {
          if (PD.getGoStatsById) {
            const stats = PD.getGoStatsById(id, level);
            if (stats && typeof stats === 'object') {
              return {
                hp: Number(stats.hp != null ? stats.hp : fallbackStats.hp),
                attack: Number(stats.attack != null ? stats.attack : fallbackStats.attack),
                defense: Number(stats.defense != null ? stats.defense : fallbackStats.defense),
                speed: Number(stats.speed != null ? stats.speed : fallbackStats.speed),
              };
            }
          }
        } catch (_) { /* ignore */ }
        return Object.assign({}, fallbackStats);
      }

      function applyLevel(level, opts) {
        const sanitized = sanitizeLevel(level, currentLevel);
        currentLevel = sanitized;
        if (levelInput) {
          const active = document.activeElement === levelInput;
          const shouldUpdate = (opts && opts.forceValue) || (!active && !(opts && opts.skipValueUpdate));
          if (shouldUpdate) levelInput.value = formatLevel(sanitized);
        }
        const stats = computeStats(sanitized);
        const cp = (PD.calcGoCp && stats) ? PD.calcGoCp(stats) : 10;
        if (cpEl) cpEl.textContent = Math.max(10, Math.round(cp));
        if (metaRowEl) metaRowEl.textContent = `Lvl ${formatLevel(sanitized)}`;
        if (hpEl) hpEl.textContent = Math.max(1, Math.round(stats.hp));
        if (atkEl) atkEl.textContent = Math.round(stats.attack);
        if (defEl) defEl.textContent = Math.round(stats.defense);
        if (spdEl) spdEl.textContent = Math.round(stats.speed);
        return sanitized;
      }

      let feedbackTimer = null;
      function showFeedback(message, isError) {
        if (!feedbackEl) return;
        if (feedbackTimer) { clearTimeout(feedbackTimer); feedbackTimer = null; }
        if (!message) {
          feedbackEl.textContent = '';
          feedbackEl.removeAttribute('data-error');
          return;
        }
        feedbackEl.textContent = message;
        if (isError) feedbackEl.setAttribute('data-error', '1');
        else feedbackEl.removeAttribute('data-error');
        feedbackTimer = window.setTimeout(() => {
          feedbackEl.textContent = '';
          feedbackEl.removeAttribute('data-error');
          feedbackTimer = null;
        }, 2200);
      }

      function persistView(extra) {
        const nextView = Object.assign({}, view || {});
        nextView.id = id;
        nextView.name = name;
        nextView.level = currentLevel;
        if (activeUid) nextView.uid = activeUid;
        if (extra && extra.uid) nextView.uid = extra.uid;
        writeState({ viewPokemon: nextView });
      }

      if (levelInput) {
        levelInput.value = formatLevel(currentLevel);
        levelInput.addEventListener('input', () => {
          applyLevel(levelInput.value, { skipValueUpdate: true });
        });
        levelInput.addEventListener('change', () => {
          applyLevel(levelInput.value, { forceValue: true });
          persistView();
        });
        levelInput.addEventListener('blur', () => {
          applyLevel(levelInput.value, { forceValue: true });
        });
      }

      applyLevel(currentLevel, { forceValue: true });

      (function updatePortrait(){
        const host = $('portrait');
        if (!host) return;
        host.textContent = '';
        const img = document.createElement('img');
        img.alt = name;
        try {
          const url = (PD.getBattleSpriteUrl ? PD.getBattleSpriteUrl(name, 'opponent', isShiny) : null) || (PD.getForwardSpriteUrl ? PD.getForwardSpriteUrl(name) : '');
          img.src = url;
        } catch (_) {}
        host.appendChild(img);

        function positionPortrait() {
          const topCard = document.querySelector('.top-card');
          const cpValueEl = document.querySelector('.cp-value');
          const nameRowEl = document.getElementById('nameRow');
          if (!topCard || !cpValueEl || !nameRowEl) return;
          const rTop = topCard.getBoundingClientRect();
          const rCp = cpValueEl.getBoundingClientRect();
          const rName = nameRowEl.getBoundingClientRect();
          const mid = ((rCp.bottom + rName.top) / 2) - rTop.top;
          host.style.top = `${mid}px`;
        }
        window.requestAnimationFrame(positionPortrait);
        window.addEventListener('resize', positionPortrait);
        img.addEventListener('load', () => window.requestAnimationFrame(positionPortrait), { once: true });
      })();

      if (backBtn) backBtn.addEventListener('click', () => {
        if (document.referrer) {
          history.back();
        } else {
          window.location.href = 'pokemon-list.html';
        }
      });

      function updateReleaseVisibility() {
        if (!releaseBtn) return;
        const hasUid = Boolean(activeUid);
        if (releaseCard) {
          releaseCard.style.display = hasUid ? '' : 'none';
        } else {
          releaseBtn.style.display = hasUid ? '' : 'none';
        }
        releaseBtn.disabled = !hasUid;
      }



      function toggleReleaseOverlay(show) {
        if (!releaseOverlay) return;
        releaseOverlay.setAttribute('aria-hidden', show ? 'false' : 'true');
        if (show) {
          releaseOverlay.classList.add('is-open');
          const focusTarget = releaseConfirmBtn || releaseCancelBtn;
          if (focusTarget) window.requestAnimationFrame(() => focusTarget.focus());
        } else {
          releaseOverlay.classList.remove('is-open');
        }
      }

      function clearPendingRelease() {
        pendingReleaseUid = '';
        releaseHandler = null;
      }

      function cancelPendingRelease() {
        const wasPending = Boolean(pendingReleaseUid);
        const wasOpen = releaseOverlay ? releaseOverlay.classList.contains('is-open') : false;
        toggleReleaseOverlay(false);
        clearPendingRelease();
        if (wasPending || wasOpen) {
          showFeedback('Release cancelled.', false);
        }
      }

      function finalizeRelease(targetUid, handler) {
        toggleReleaseOverlay(false);
        clearPendingRelease();
        if (!targetUid || !handler) {
          showFeedback('Unable to release this Pokemon.', true);
          return;
        }
        const removed = handler.call(window.PlayerCollection, targetUid);
        if (!removed) {
          showFeedback('Unable to release this Pokemon: failed to find.', true);
          return;
        }
        const latest = readState();
        if (latest && latest.viewPokemon && latest.viewPokemon.uid === targetUid) {
          const nextView = Object.assign({}, latest.viewPokemon);
          delete nextView.uid;
          writeState({ viewPokemon: nextView });
        }
        activeUid = '';
        existingEntry = null;
        updateSaveLabel();
        updateReleaseVisibility();
        showFeedback('Pokemon released.', false);
        window.setTimeout(() => {
          window.location.href = 'pokemon-list.html';
        }, 300);
      }


if (saveBtn) {
        updateSaveLabel = function () {
          saveBtn.textContent = activeUid ? 'Update Pokemon' : 'Save Pokemon';
        };
        updateSaveLabel();
        saveBtn.addEventListener('click', () => {
          if (!id) {
            showFeedback('Unable to save this Pokemon.', true);
            return;
          }
          const levelToSave = applyLevel(levelInput ? levelInput.value : currentLevel, { forceValue: true });
          const latestState = readState();
          const latestCollection = getCollection(latestState);
          const timestamp = Date.now();
          let uid = activeUid;
          let existed = false;
          const nextCollection = latestCollection.slice();
          if (uid) {
            const index = nextCollection.findIndex((item) => item.uid === uid);
            if (index !== -1) {
              existed = true;
              const prev = nextCollection[index];
              nextCollection[index] = {
                uid,
                id,
                level: levelToSave,
                name,
                createdAt: prev && prev.createdAt ? prev.createdAt : timestamp,
              };
            } else {
              uid = '';
            }
          }
          if (!uid) {
            uid = `pk_${timestamp.toString(36)}${Math.random().toString(36).slice(2, 8)}`;
            nextCollection.push({
              uid,
              id,
              level: levelToSave,
              name,
              createdAt: timestamp,
            });
          }
          activeUid = uid;
          existingEntry = nextCollection.find((item) => item.uid === uid) || existingEntry;
          const nextView = Object.assign({}, view || {}, { id, name, level: levelToSave, uid });
          writeState({ playerPokemon: nextCollection, viewPokemon: nextView });
          updateReleaseVisibility();
          updateSaveLabel();
          showFeedback(existed ? 'Pokemon updated!' : 'Pokemon saved!', false);
        });
      }

      if (releaseBtn) {
        updateReleaseVisibility();
        releaseBtn.addEventListener('click', () => {
          if (!activeUid) {
            showFeedback('This Pokemon is not saved yet.', true);
            return;
          }
          const handler = window.PlayerCollection && typeof window.PlayerCollection.releasePokemon === 'function'
            ? window.PlayerCollection.releasePokemon
            : null;
          if (!handler) {
            showFeedback('Unable to release this Pokemon.', true);
            return;
          }
          if (!releaseOverlay || !releaseConfirmBtn || !releaseCancelBtn) {
            const confirmed = window.confirm('Release this Pokemon from your collection?');
            if (!confirmed) {
              showFeedback('Release cancelled.', false);
              return;
            }
            finalizeRelease(activeUid, handler);
            return;
          }
          pendingReleaseUid = activeUid;
          releaseHandler = handler;
          toggleReleaseOverlay(true);
        });
      }

      if (releaseCancelBtn) {
        releaseCancelBtn.addEventListener('click', () => {
          cancelPendingRelease();
        });
      }

      if (releaseConfirmBtn) {
        releaseConfirmBtn.addEventListener('click', () => {
          const targetUid = pendingReleaseUid;
          const handler = releaseHandler;
          finalizeRelease(targetUid, handler);
        });
      }


      if (releaseOverlay) {
        releaseOverlay.addEventListener('click', (event) => {
          if (event.target === releaseOverlay) {
            cancelPendingRelease();
          }
        });
      }

      document.addEventListener('keydown', (event) => {
        if ((event.key === 'Escape' || event.key === 'Esc') && releaseOverlay && releaseOverlay.classList.contains('is-open')) {
          cancelPendingRelease();
        }
      });

      if (powerBtn) {
        powerBtn.addEventListener('click', () => {
          const nextLevel = Math.min(50, currentLevel + 0.5);
          if (nextLevel === currentLevel) {
            showFeedback('Pokemon is at max level.', false);
            return;
          }
          const applied = applyLevel(nextLevel, { forceValue: true });
          persistView();
          showFeedback(`Level ${formatLevel(applied)} selected.`, false);
        });
      }
    })();
  </script>
</body>
</html>
